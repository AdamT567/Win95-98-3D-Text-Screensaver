<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/TextGeometry.js';

const params = Object.fromEntries(new URLSearchParams(location.search).entries());
params.size  = parseFloat(params.size  ?? '1.2');
params.speed = parseFloat(params.speed ?? '1.0');

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(45, 2, 0.1, 100);
camera.position.set(0,0,12);
scene.add(new THREE.DirectionalLight(0xffffff,1).position.set(3,5,8));
scene.add(new THREE.AmbientLight(0xffffff,0.25));

const material = (()=> {
  if (params.surface === 'texture' && params.texture) {
    const tex = new THREE.TextureLoader().load(params.texture);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    return new THREE.MeshPhongMaterial({ map: tex });
  }
  return new THREE.MeshPhongMaterial({ color: params.color || '#ffffff', shininess: 40 });
})();

let mesh;
new FontLoader().load(
  'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json',
  font => {
    const geo = new TextGeometry(params.text || 'Be Right Back', {
      font, size: 1.5 * params.size, height: 0.5, curveSegments: 8,
      bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.03, bevelSegments: 2
    });
    geo.computeBoundingBox();
    geo.center();
    mesh = new THREE.Mesh(geo, material);
    scene.add(mesh);
  }
);

function resize(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  if (canvas.width !== w || canvas.height !== h) {
    renderer.setSize(w, h, false);
    camera.aspect = w / h; camera.updateProjectionMatrix();
  }
}
window.addEventListener('resize', resize);

let t0 = performance.now();
function tick(now){
  requestAnimationFrame(tick);
  resize();
  if (mesh){
    const t = (now - t0) * 0.001 * params.speed;
    switch(params.spin){
      case 'spin':   mesh.rotation.y = t; break;
      case 'bounce': mesh.rotation.y = t*0.6; mesh.position.y = Math.sin(t)*0.5; break;
      case 'random': mesh.rotation.x = Math.sin(t*0.9)*0.6; mesh.rotation.y = Math.cos(t*1.1)*0.8; mesh.rotation.z = Math.sin(t*0.7)*0.4; break;
      default:       mesh.rotation.y = t*0.8; mesh.rotation.x = Math.sin(t)*0.2; mesh.rotation.z = Math.cos(t*0.5)*0.1;
    }
  }
  renderer.render(scene, camera);
}
tick();
</script>
